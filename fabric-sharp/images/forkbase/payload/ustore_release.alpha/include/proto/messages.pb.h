// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto

#ifndef PROTOBUF_INCLUDED_messages_2eproto
#define PROTOBUF_INCLUDED_messages_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_messages_2eproto 

namespace protobuf_messages_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[8];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_messages_2eproto
namespace ustore {
class InfoPayload;
class InfoPayloadDefaultTypeInternal;
extern InfoPayloadDefaultTypeInternal _InfoPayload_default_instance_;
class RangeInfo;
class RangeInfoDefaultTypeInternal;
extern RangeInfoDefaultTypeInternal _RangeInfo_default_instance_;
class RangeRequest;
class RangeRequestDefaultTypeInternal;
extern RangeRequestDefaultTypeInternal _RangeRequest_default_instance_;
class RangeResponse;
class RangeResponseDefaultTypeInternal;
extern RangeResponseDefaultTypeInternal _RangeResponse_default_instance_;
class RequestPayload;
class RequestPayloadDefaultTypeInternal;
extern RequestPayloadDefaultTypeInternal _RequestPayload_default_instance_;
class ResponsePayload;
class ResponsePayloadDefaultTypeInternal;
extern ResponsePayloadDefaultTypeInternal _ResponsePayload_default_instance_;
class UMessage;
class UMessageDefaultTypeInternal;
extern UMessageDefaultTypeInternal _UMessage_default_instance_;
class ValuePayload;
class ValuePayloadDefaultTypeInternal;
extern ValuePayloadDefaultTypeInternal _ValuePayload_default_instance_;
}  // namespace ustore
namespace google {
namespace protobuf {
template<> ::ustore::InfoPayload* Arena::CreateMaybeMessage<::ustore::InfoPayload>(Arena*);
template<> ::ustore::RangeInfo* Arena::CreateMaybeMessage<::ustore::RangeInfo>(Arena*);
template<> ::ustore::RangeRequest* Arena::CreateMaybeMessage<::ustore::RangeRequest>(Arena*);
template<> ::ustore::RangeResponse* Arena::CreateMaybeMessage<::ustore::RangeResponse>(Arena*);
template<> ::ustore::RequestPayload* Arena::CreateMaybeMessage<::ustore::RequestPayload>(Arena*);
template<> ::ustore::ResponsePayload* Arena::CreateMaybeMessage<::ustore::ResponsePayload>(Arena*);
template<> ::ustore::UMessage* Arena::CreateMaybeMessage<::ustore::UMessage>(Arena*);
template<> ::ustore::ValuePayload* Arena::CreateMaybeMessage<::ustore::ValuePayload>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace ustore {

enum UMessage_Type {
  UMessage_Type_PUT_REQUEST = 1,
  UMessage_Type_GET_REQUEST = 2,
  UMessage_Type_MERGE_REQUEST = 3,
  UMessage_Type_LIST_REQUEST = 10,
  UMessage_Type_EXISTS_REQUEST = 11,
  UMessage_Type_GET_BRANCH_HEAD_REQUEST = 12,
  UMessage_Type_IS_BRANCH_HEAD_REQUEST = 13,
  UMessage_Type_GET_LATEST_VERSION_REQUEST = 14,
  UMessage_Type_IS_LATEST_VERSION_REQUEST = 15,
  UMessage_Type_BRANCH_REQUEST = 20,
  UMessage_Type_RENAME_REQUEST = 21,
  UMessage_Type_DELETE_REQUEST = 22,
  UMessage_Type_GET_INFO_REQUEST = 31,
  UMessage_Type_PUT_CHUNK_REQUEST = 40,
  UMessage_Type_GET_CHUNK_REQUEST = 41,
  UMessage_Type_EXISTS_CHUNK_REQUEST = 42,
  UMessage_Type_RESPONSE = 50
};
bool UMessage_Type_IsValid(int value);
const UMessage_Type UMessage_Type_Type_MIN = UMessage_Type_PUT_REQUEST;
const UMessage_Type UMessage_Type_Type_MAX = UMessage_Type_RESPONSE;
const int UMessage_Type_Type_ARRAYSIZE = UMessage_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* UMessage_Type_descriptor();
inline const ::std::string& UMessage_Type_Name(UMessage_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    UMessage_Type_descriptor(), value);
}
inline bool UMessage_Type_Parse(
    const ::std::string& name, UMessage_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UMessage_Type>(
    UMessage_Type_descriptor(), name, value);
}
// ===================================================================

class UMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ustore.UMessage) */ {
 public:
  UMessage();
  virtual ~UMessage();

  UMessage(const UMessage& from);

  inline UMessage& operator=(const UMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UMessage(UMessage&& from) noexcept
    : UMessage() {
    *this = ::std::move(from);
  }

  inline UMessage& operator=(UMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UMessage* internal_default_instance() {
    return reinterpret_cast<const UMessage*>(
               &_UMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(UMessage* other);
  friend void swap(UMessage& a, UMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UMessage* New() const final {
    return CreateMaybeMessage<UMessage>(NULL);
  }

  UMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UMessage& from);
  void MergeFrom(const UMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UMessage_Type Type;
  static const Type PUT_REQUEST =
    UMessage_Type_PUT_REQUEST;
  static const Type GET_REQUEST =
    UMessage_Type_GET_REQUEST;
  static const Type MERGE_REQUEST =
    UMessage_Type_MERGE_REQUEST;
  static const Type LIST_REQUEST =
    UMessage_Type_LIST_REQUEST;
  static const Type EXISTS_REQUEST =
    UMessage_Type_EXISTS_REQUEST;
  static const Type GET_BRANCH_HEAD_REQUEST =
    UMessage_Type_GET_BRANCH_HEAD_REQUEST;
  static const Type IS_BRANCH_HEAD_REQUEST =
    UMessage_Type_IS_BRANCH_HEAD_REQUEST;
  static const Type GET_LATEST_VERSION_REQUEST =
    UMessage_Type_GET_LATEST_VERSION_REQUEST;
  static const Type IS_LATEST_VERSION_REQUEST =
    UMessage_Type_IS_LATEST_VERSION_REQUEST;
  static const Type BRANCH_REQUEST =
    UMessage_Type_BRANCH_REQUEST;
  static const Type RENAME_REQUEST =
    UMessage_Type_RENAME_REQUEST;
  static const Type DELETE_REQUEST =
    UMessage_Type_DELETE_REQUEST;
  static const Type GET_INFO_REQUEST =
    UMessage_Type_GET_INFO_REQUEST;
  static const Type PUT_CHUNK_REQUEST =
    UMessage_Type_PUT_CHUNK_REQUEST;
  static const Type GET_CHUNK_REQUEST =
    UMessage_Type_GET_CHUNK_REQUEST;
  static const Type EXISTS_CHUNK_REQUEST =
    UMessage_Type_EXISTS_CHUNK_REQUEST;
  static const Type RESPONSE =
    UMessage_Type_RESPONSE;
  static inline bool Type_IsValid(int value) {
    return UMessage_Type_IsValid(value);
  }
  static const Type Type_MIN =
    UMessage_Type_Type_MIN;
  static const Type Type_MAX =
    UMessage_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    UMessage_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return UMessage_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return UMessage_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return UMessage_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .ustore.RequestPayload request_payload = 10;
  bool has_request_payload() const;
  void clear_request_payload();
  static const int kRequestPayloadFieldNumber = 10;
  private:
  const ::ustore::RequestPayload& _internal_request_payload() const;
  public:
  const ::ustore::RequestPayload& request_payload() const;
  ::ustore::RequestPayload* release_request_payload();
  ::ustore::RequestPayload* mutable_request_payload();
  void set_allocated_request_payload(::ustore::RequestPayload* request_payload);

  // optional .ustore.ValuePayload value_payload = 11;
  bool has_value_payload() const;
  void clear_value_payload();
  static const int kValuePayloadFieldNumber = 11;
  private:
  const ::ustore::ValuePayload& _internal_value_payload() const;
  public:
  const ::ustore::ValuePayload& value_payload() const;
  ::ustore::ValuePayload* release_value_payload();
  ::ustore::ValuePayload* mutable_value_payload();
  void set_allocated_value_payload(::ustore::ValuePayload* value_payload);

  // optional .ustore.ResponsePayload response_payload = 12;
  bool has_response_payload() const;
  void clear_response_payload();
  static const int kResponsePayloadFieldNumber = 12;
  private:
  const ::ustore::ResponsePayload& _internal_response_payload() const;
  public:
  const ::ustore::ResponsePayload& response_payload() const;
  ::ustore::ResponsePayload* release_response_payload();
  ::ustore::ResponsePayload* mutable_response_payload();
  void set_allocated_response_payload(::ustore::ResponsePayload* response_payload);

  // optional .ustore.InfoPayload info_payload = 13;
  bool has_info_payload() const;
  void clear_info_payload();
  static const int kInfoPayloadFieldNumber = 13;
  private:
  const ::ustore::InfoPayload& _internal_info_payload() const;
  public:
  const ::ustore::InfoPayload& info_payload() const;
  ::ustore::InfoPayload* release_info_payload();
  ::ustore::InfoPayload* mutable_info_payload();
  void set_allocated_info_payload(::ustore::InfoPayload* info_payload);

  // required int32 source = 2;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 2;
  ::google::protobuf::int32 source() const;
  void set_source(::google::protobuf::int32 value);

  // required .ustore.UMessage.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::ustore::UMessage_Type type() const;
  void set_type(::ustore::UMessage_Type value);

  // @@protoc_insertion_point(class_scope:ustore.UMessage)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_source();
  void clear_has_source();
  void set_has_request_payload();
  void clear_has_request_payload();
  void set_has_value_payload();
  void clear_has_value_payload();
  void set_has_response_payload();
  void clear_has_response_payload();
  void set_has_info_payload();
  void clear_has_info_payload();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ustore::RequestPayload* request_payload_;
  ::ustore::ValuePayload* value_payload_;
  ::ustore::ResponsePayload* response_payload_;
  ::ustore::InfoPayload* info_payload_;
  ::google::protobuf::int32 source_;
  int type_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestPayload : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ustore.RequestPayload) */ {
 public:
  RequestPayload();
  virtual ~RequestPayload();

  RequestPayload(const RequestPayload& from);

  inline RequestPayload& operator=(const RequestPayload& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestPayload(RequestPayload&& from) noexcept
    : RequestPayload() {
    *this = ::std::move(from);
  }

  inline RequestPayload& operator=(RequestPayload&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestPayload& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestPayload* internal_default_instance() {
    return reinterpret_cast<const RequestPayload*>(
               &_RequestPayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(RequestPayload* other);
  friend void swap(RequestPayload& a, RequestPayload& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestPayload* New() const final {
    return CreateMaybeMessage<RequestPayload>(NULL);
  }

  RequestPayload* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestPayload>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestPayload& from);
  void MergeFrom(const RequestPayload& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestPayload* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional bytes version = 2;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const void* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // optional bytes branch = 3;
  bool has_branch() const;
  void clear_branch();
  static const int kBranchFieldNumber = 3;
  const ::std::string& branch() const;
  void set_branch(const ::std::string& value);
  #if LANG_CXX11
  void set_branch(::std::string&& value);
  #endif
  void set_branch(const char* value);
  void set_branch(const void* value, size_t size);
  ::std::string* mutable_branch();
  ::std::string* release_branch();
  void set_allocated_branch(::std::string* branch);

  // optional bytes ref_version = 4;
  bool has_ref_version() const;
  void clear_ref_version();
  static const int kRefVersionFieldNumber = 4;
  const ::std::string& ref_version() const;
  void set_ref_version(const ::std::string& value);
  #if LANG_CXX11
  void set_ref_version(::std::string&& value);
  #endif
  void set_ref_version(const char* value);
  void set_ref_version(const void* value, size_t size);
  ::std::string* mutable_ref_version();
  ::std::string* release_ref_version();
  void set_allocated_ref_version(::std::string* ref_version);

  // optional bytes ref_branch = 5;
  bool has_ref_branch() const;
  void clear_ref_branch();
  static const int kRefBranchFieldNumber = 5;
  const ::std::string& ref_branch() const;
  void set_ref_branch(const ::std::string& value);
  #if LANG_CXX11
  void set_ref_branch(::std::string&& value);
  #endif
  void set_ref_branch(const char* value);
  void set_ref_branch(const void* value, size_t size);
  ::std::string* mutable_ref_branch();
  ::std::string* release_ref_branch();
  void set_allocated_ref_branch(::std::string* ref_branch);

  // @@protoc_insertion_point(class_scope:ustore.RequestPayload)
 private:
  void set_has_key();
  void clear_has_key();
  void set_has_version();
  void clear_has_version();
  void set_has_branch();
  void clear_has_branch();
  void set_has_ref_version();
  void clear_has_ref_version();
  void set_has_ref_branch();
  void clear_has_ref_branch();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr branch_;
  ::google::protobuf::internal::ArenaStringPtr ref_version_;
  ::google::protobuf::internal::ArenaStringPtr ref_branch_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ValuePayload : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ustore.ValuePayload) */ {
 public:
  ValuePayload();
  virtual ~ValuePayload();

  ValuePayload(const ValuePayload& from);

  inline ValuePayload& operator=(const ValuePayload& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ValuePayload(ValuePayload&& from) noexcept
    : ValuePayload() {
    *this = ::std::move(from);
  }

  inline ValuePayload& operator=(ValuePayload&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ValuePayload& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ValuePayload* internal_default_instance() {
    return reinterpret_cast<const ValuePayload*>(
               &_ValuePayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ValuePayload* other);
  friend void swap(ValuePayload& a, ValuePayload& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ValuePayload* New() const final {
    return CreateMaybeMessage<ValuePayload>(NULL);
  }

  ValuePayload* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ValuePayload>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ValuePayload& from);
  void MergeFrom(const ValuePayload& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValuePayload* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes values = 5;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 5;
  const ::std::string& values(int index) const;
  ::std::string* mutable_values(int index);
  void set_values(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_values(int index, ::std::string&& value);
  #endif
  void set_values(int index, const char* value);
  void set_values(int index, const void* value, size_t size);
  ::std::string* add_values();
  void add_values(const ::std::string& value);
  #if LANG_CXX11
  void add_values(::std::string&& value);
  #endif
  void add_values(const char* value);
  void add_values(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& values() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_values();

  // repeated bytes keys = 6;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 6;
  const ::std::string& keys(int index) const;
  ::std::string* mutable_keys(int index);
  void set_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_keys(int index, ::std::string&& value);
  #endif
  void set_keys(int index, const char* value);
  void set_keys(int index, const void* value, size_t size);
  ::std::string* add_keys();
  void add_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_keys(::std::string&& value);
  #endif
  void add_keys(const char* value);
  void add_keys(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // optional bytes base = 2;
  bool has_base() const;
  void clear_base();
  static const int kBaseFieldNumber = 2;
  const ::std::string& base() const;
  void set_base(const ::std::string& value);
  #if LANG_CXX11
  void set_base(::std::string&& value);
  #endif
  void set_base(const char* value);
  void set_base(const void* value, size_t size);
  ::std::string* mutable_base();
  ::std::string* release_base();
  void set_allocated_base(::std::string* base);

  // optional bytes ctx = 10;
  bool has_ctx() const;
  void clear_ctx();
  static const int kCtxFieldNumber = 10;
  const ::std::string& ctx() const;
  void set_ctx(const ::std::string& value);
  #if LANG_CXX11
  void set_ctx(::std::string&& value);
  #endif
  void set_ctx(const char* value);
  void set_ctx(const void* value, size_t size);
  ::std::string* mutable_ctx();
  ::std::string* release_ctx();
  void set_allocated_ctx(::std::string* ctx);

  // optional int32 type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // optional int32 pos = 3;
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 3;
  ::google::protobuf::int32 pos() const;
  void set_pos(::google::protobuf::int32 value);

  // optional int32 dels = 4;
  bool has_dels() const;
  void clear_dels();
  static const int kDelsFieldNumber = 4;
  ::google::protobuf::int32 dels() const;
  void set_dels(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ustore.ValuePayload)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_base();
  void clear_has_base();
  void set_has_pos();
  void clear_has_pos();
  void set_has_dels();
  void clear_has_dels();
  void set_has_ctx();
  void clear_has_ctx();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> values_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  ::google::protobuf::internal::ArenaStringPtr base_;
  ::google::protobuf::internal::ArenaStringPtr ctx_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 pos_;
  ::google::protobuf::int32 dels_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponsePayload : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ustore.ResponsePayload) */ {
 public:
  ResponsePayload();
  virtual ~ResponsePayload();

  ResponsePayload(const ResponsePayload& from);

  inline ResponsePayload& operator=(const ResponsePayload& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponsePayload(ResponsePayload&& from) noexcept
    : ResponsePayload() {
    *this = ::std::move(from);
  }

  inline ResponsePayload& operator=(ResponsePayload&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponsePayload& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponsePayload* internal_default_instance() {
    return reinterpret_cast<const ResponsePayload*>(
               &_ResponsePayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ResponsePayload* other);
  friend void swap(ResponsePayload& a, ResponsePayload& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponsePayload* New() const final {
    return CreateMaybeMessage<ResponsePayload>(NULL);
  }

  ResponsePayload* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponsePayload>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponsePayload& from);
  void MergeFrom(const ResponsePayload& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponsePayload* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes lvalue = 4;
  int lvalue_size() const;
  void clear_lvalue();
  static const int kLvalueFieldNumber = 4;
  const ::std::string& lvalue(int index) const;
  ::std::string* mutable_lvalue(int index);
  void set_lvalue(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_lvalue(int index, ::std::string&& value);
  #endif
  void set_lvalue(int index, const char* value);
  void set_lvalue(int index, const void* value, size_t size);
  ::std::string* add_lvalue();
  void add_lvalue(const ::std::string& value);
  #if LANG_CXX11
  void add_lvalue(::std::string&& value);
  #endif
  void add_lvalue(const char* value);
  void add_lvalue(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& lvalue() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_lvalue();

  // optional bytes value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // required int32 stat = 1;
  bool has_stat() const;
  void clear_stat();
  static const int kStatFieldNumber = 1;
  ::google::protobuf::int32 stat() const;
  void set_stat(::google::protobuf::int32 value);

  // optional bool bvalue = 3;
  bool has_bvalue() const;
  void clear_bvalue();
  static const int kBvalueFieldNumber = 3;
  bool bvalue() const;
  void set_bvalue(bool value);

  // @@protoc_insertion_point(class_scope:ustore.ResponsePayload)
 private:
  void set_has_stat();
  void clear_has_stat();
  void set_has_value();
  void clear_has_value();
  void set_has_bvalue();
  void clear_has_bvalue();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> lvalue_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::int32 stat_;
  bool bvalue_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InfoPayload : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ustore.InfoPayload) */ {
 public:
  InfoPayload();
  virtual ~InfoPayload();

  InfoPayload(const InfoPayload& from);

  inline InfoPayload& operator=(const InfoPayload& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InfoPayload(InfoPayload&& from) noexcept
    : InfoPayload() {
    *this = ::std::move(from);
  }

  inline InfoPayload& operator=(InfoPayload&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InfoPayload& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InfoPayload* internal_default_instance() {
    return reinterpret_cast<const InfoPayload*>(
               &_InfoPayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(InfoPayload* other);
  friend void swap(InfoPayload& a, InfoPayload& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InfoPayload* New() const final {
    return CreateMaybeMessage<InfoPayload>(NULL);
  }

  InfoPayload* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InfoPayload>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InfoPayload& from);
  void MergeFrom(const InfoPayload& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InfoPayload* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 chunk_types = 10;
  int chunk_types_size() const;
  void clear_chunk_types();
  static const int kChunkTypesFieldNumber = 10;
  ::google::protobuf::int32 chunk_types(int index) const;
  void set_chunk_types(int index, ::google::protobuf::int32 value);
  void add_chunk_types(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      chunk_types() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_chunk_types();

  // repeated int64 chunks_per_type = 11;
  int chunks_per_type_size() const;
  void clear_chunks_per_type();
  static const int kChunksPerTypeFieldNumber = 11;
  ::google::protobuf::int64 chunks_per_type(int index) const;
  void set_chunks_per_type(int index, ::google::protobuf::int64 value);
  void add_chunks_per_type(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      chunks_per_type() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_chunks_per_type();

  // repeated int64 bytes_per_type = 12;
  int bytes_per_type_size() const;
  void clear_bytes_per_type();
  static const int kBytesPerTypeFieldNumber = 12;
  ::google::protobuf::int64 bytes_per_type(int index) const;
  void set_bytes_per_type(int index, ::google::protobuf::int64 value);
  void add_bytes_per_type(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      bytes_per_type() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_bytes_per_type();

  // required bytes node_id = 20;
  bool has_node_id() const;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 20;
  const ::std::string& node_id() const;
  void set_node_id(const ::std::string& value);
  #if LANG_CXX11
  void set_node_id(::std::string&& value);
  #endif
  void set_node_id(const char* value);
  void set_node_id(const void* value, size_t size);
  ::std::string* mutable_node_id();
  ::std::string* release_node_id();
  void set_allocated_node_id(::std::string* node_id);

  // required int64 chunks = 1;
  bool has_chunks() const;
  void clear_chunks();
  static const int kChunksFieldNumber = 1;
  ::google::protobuf::int64 chunks() const;
  void set_chunks(::google::protobuf::int64 value);

  // required int64 chunk_bytes = 2;
  bool has_chunk_bytes() const;
  void clear_chunk_bytes();
  static const int kChunkBytesFieldNumber = 2;
  ::google::protobuf::int64 chunk_bytes() const;
  void set_chunk_bytes(::google::protobuf::int64 value);

  // required int64 valid_chunks = 3;
  bool has_valid_chunks() const;
  void clear_valid_chunks();
  static const int kValidChunksFieldNumber = 3;
  ::google::protobuf::int64 valid_chunks() const;
  void set_valid_chunks(::google::protobuf::int64 value);

  // required int64 valid_chunk_bytes = 4;
  bool has_valid_chunk_bytes() const;
  void clear_valid_chunk_bytes();
  static const int kValidChunkBytesFieldNumber = 4;
  ::google::protobuf::int64 valid_chunk_bytes() const;
  void set_valid_chunk_bytes(::google::protobuf::int64 value);

  // required int64 max_segments = 5;
  bool has_max_segments() const;
  void clear_max_segments();
  static const int kMaxSegmentsFieldNumber = 5;
  ::google::protobuf::int64 max_segments() const;
  void set_max_segments(::google::protobuf::int64 value);

  // required int64 alloc_segments = 6;
  bool has_alloc_segments() const;
  void clear_alloc_segments();
  static const int kAllocSegmentsFieldNumber = 6;
  ::google::protobuf::int64 alloc_segments() const;
  void set_alloc_segments(::google::protobuf::int64 value);

  // required int64 free_segments = 7;
  bool has_free_segments() const;
  void clear_free_segments();
  static const int kFreeSegmentsFieldNumber = 7;
  ::google::protobuf::int64 free_segments() const;
  void set_free_segments(::google::protobuf::int64 value);

  // required int64 used_segments = 8;
  bool has_used_segments() const;
  void clear_used_segments();
  static const int kUsedSegmentsFieldNumber = 8;
  ::google::protobuf::int64 used_segments() const;
  void set_used_segments(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ustore.InfoPayload)
 private:
  void set_has_node_id();
  void clear_has_node_id();
  void set_has_chunks();
  void clear_has_chunks();
  void set_has_chunk_bytes();
  void clear_has_chunk_bytes();
  void set_has_valid_chunks();
  void clear_has_valid_chunks();
  void set_has_valid_chunk_bytes();
  void clear_has_valid_chunk_bytes();
  void set_has_max_segments();
  void clear_has_max_segments();
  void set_has_alloc_segments();
  void clear_has_alloc_segments();
  void set_has_free_segments();
  void clear_has_free_segments();
  void set_has_used_segments();
  void clear_has_used_segments();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > chunk_types_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > chunks_per_type_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > bytes_per_type_;
  ::google::protobuf::internal::ArenaStringPtr node_id_;
  ::google::protobuf::int64 chunks_;
  ::google::protobuf::int64 chunk_bytes_;
  ::google::protobuf::int64 valid_chunks_;
  ::google::protobuf::int64 valid_chunk_bytes_;
  ::google::protobuf::int64 max_segments_;
  ::google::protobuf::int64 alloc_segments_;
  ::google::protobuf::int64 free_segments_;
  ::google::protobuf::int64 used_segments_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RangeRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ustore.RangeRequest) */ {
 public:
  RangeRequest();
  virtual ~RangeRequest();

  RangeRequest(const RangeRequest& from);

  inline RangeRequest& operator=(const RangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RangeRequest(RangeRequest&& from) noexcept
    : RangeRequest() {
    *this = ::std::move(from);
  }

  inline RangeRequest& operator=(RangeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RangeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RangeRequest* internal_default_instance() {
    return reinterpret_cast<const RangeRequest*>(
               &_RangeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(RangeRequest* other);
  friend void swap(RangeRequest& a, RangeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RangeRequest* New() const final {
    return CreateMaybeMessage<RangeRequest>(NULL);
  }

  RangeRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RangeRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RangeRequest& from);
  void MergeFrom(const RangeRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RangeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:ustore.RangeRequest)
 private:
  void set_has_key();
  void clear_has_key();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RangeResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ustore.RangeResponse) */ {
 public:
  RangeResponse();
  virtual ~RangeResponse();

  RangeResponse(const RangeResponse& from);

  inline RangeResponse& operator=(const RangeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RangeResponse(RangeResponse&& from) noexcept
    : RangeResponse() {
    *this = ::std::move(from);
  }

  inline RangeResponse& operator=(RangeResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RangeResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RangeResponse* internal_default_instance() {
    return reinterpret_cast<const RangeResponse*>(
               &_RangeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(RangeResponse* other);
  friend void swap(RangeResponse& a, RangeResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RangeResponse* New() const final {
    return CreateMaybeMessage<RangeResponse>(NULL);
  }

  RangeResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RangeResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RangeResponse& from);
  void MergeFrom(const RangeResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RangeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ustore.RangeInfo range_map = 1;
  int range_map_size() const;
  void clear_range_map();
  static const int kRangeMapFieldNumber = 1;
  ::ustore::RangeInfo* mutable_range_map(int index);
  ::google::protobuf::RepeatedPtrField< ::ustore::RangeInfo >*
      mutable_range_map();
  const ::ustore::RangeInfo& range_map(int index) const;
  ::ustore::RangeInfo* add_range_map();
  const ::google::protobuf::RepeatedPtrField< ::ustore::RangeInfo >&
      range_map() const;

  // @@protoc_insertion_point(class_scope:ustore.RangeResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ustore::RangeInfo > range_map_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RangeInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ustore.RangeInfo) */ {
 public:
  RangeInfo();
  virtual ~RangeInfo();

  RangeInfo(const RangeInfo& from);

  inline RangeInfo& operator=(const RangeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RangeInfo(RangeInfo&& from) noexcept
    : RangeInfo() {
    *this = ::std::move(from);
  }

  inline RangeInfo& operator=(RangeInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RangeInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RangeInfo* internal_default_instance() {
    return reinterpret_cast<const RangeInfo*>(
               &_RangeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(RangeInfo* other);
  friend void swap(RangeInfo& a, RangeInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RangeInfo* New() const final {
    return CreateMaybeMessage<RangeInfo>(NULL);
  }

  RangeInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RangeInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RangeInfo& from);
  void MergeFrom(const RangeInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RangeInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes start = 1;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 1;
  const ::std::string& start() const;
  void set_start(const ::std::string& value);
  #if LANG_CXX11
  void set_start(::std::string&& value);
  #endif
  void set_start(const char* value);
  void set_start(const void* value, size_t size);
  ::std::string* mutable_start();
  ::std::string* release_start();
  void set_allocated_start(::std::string* start);

  // optional bytes end = 2;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 2;
  const ::std::string& end() const;
  void set_end(const ::std::string& value);
  #if LANG_CXX11
  void set_end(::std::string&& value);
  #endif
  void set_end(const char* value);
  void set_end(const void* value, size_t size);
  ::std::string* mutable_end();
  ::std::string* release_end();
  void set_allocated_end(::std::string* end);

  // required string address = 4;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 4;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // @@protoc_insertion_point(class_scope:ustore.RangeInfo)
 private:
  void set_has_start();
  void clear_has_start();
  void set_has_end();
  void clear_has_end();
  void set_has_address();
  void clear_has_address();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr start_;
  ::google::protobuf::internal::ArenaStringPtr end_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// UMessage

// required .ustore.UMessage.Type type = 1;
inline bool UMessage::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UMessage::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UMessage::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::ustore::UMessage_Type UMessage::type() const {
  // @@protoc_insertion_point(field_get:ustore.UMessage.type)
  return static_cast< ::ustore::UMessage_Type >(type_);
}
inline void UMessage::set_type(::ustore::UMessage_Type value) {
  assert(::ustore::UMessage_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ustore.UMessage.type)
}

// required int32 source = 2;
inline bool UMessage::has_source() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UMessage::set_has_source() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UMessage::clear_has_source() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UMessage::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::google::protobuf::int32 UMessage::source() const {
  // @@protoc_insertion_point(field_get:ustore.UMessage.source)
  return source_;
}
inline void UMessage::set_source(::google::protobuf::int32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:ustore.UMessage.source)
}

// optional .ustore.RequestPayload request_payload = 10;
inline bool UMessage::has_request_payload() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UMessage::set_has_request_payload() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UMessage::clear_has_request_payload() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UMessage::clear_request_payload() {
  if (request_payload_ != NULL) request_payload_->Clear();
  clear_has_request_payload();
}
inline const ::ustore::RequestPayload& UMessage::_internal_request_payload() const {
  return *request_payload_;
}
inline const ::ustore::RequestPayload& UMessage::request_payload() const {
  const ::ustore::RequestPayload* p = request_payload_;
  // @@protoc_insertion_point(field_get:ustore.UMessage.request_payload)
  return p != NULL ? *p : *reinterpret_cast<const ::ustore::RequestPayload*>(
      &::ustore::_RequestPayload_default_instance_);
}
inline ::ustore::RequestPayload* UMessage::release_request_payload() {
  // @@protoc_insertion_point(field_release:ustore.UMessage.request_payload)
  clear_has_request_payload();
  ::ustore::RequestPayload* temp = request_payload_;
  request_payload_ = NULL;
  return temp;
}
inline ::ustore::RequestPayload* UMessage::mutable_request_payload() {
  set_has_request_payload();
  if (request_payload_ == NULL) {
    auto* p = CreateMaybeMessage<::ustore::RequestPayload>(GetArenaNoVirtual());
    request_payload_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ustore.UMessage.request_payload)
  return request_payload_;
}
inline void UMessage::set_allocated_request_payload(::ustore::RequestPayload* request_payload) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete request_payload_;
  }
  if (request_payload) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      request_payload = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, request_payload, submessage_arena);
    }
    set_has_request_payload();
  } else {
    clear_has_request_payload();
  }
  request_payload_ = request_payload;
  // @@protoc_insertion_point(field_set_allocated:ustore.UMessage.request_payload)
}

// optional .ustore.ValuePayload value_payload = 11;
inline bool UMessage::has_value_payload() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UMessage::set_has_value_payload() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UMessage::clear_has_value_payload() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UMessage::clear_value_payload() {
  if (value_payload_ != NULL) value_payload_->Clear();
  clear_has_value_payload();
}
inline const ::ustore::ValuePayload& UMessage::_internal_value_payload() const {
  return *value_payload_;
}
inline const ::ustore::ValuePayload& UMessage::value_payload() const {
  const ::ustore::ValuePayload* p = value_payload_;
  // @@protoc_insertion_point(field_get:ustore.UMessage.value_payload)
  return p != NULL ? *p : *reinterpret_cast<const ::ustore::ValuePayload*>(
      &::ustore::_ValuePayload_default_instance_);
}
inline ::ustore::ValuePayload* UMessage::release_value_payload() {
  // @@protoc_insertion_point(field_release:ustore.UMessage.value_payload)
  clear_has_value_payload();
  ::ustore::ValuePayload* temp = value_payload_;
  value_payload_ = NULL;
  return temp;
}
inline ::ustore::ValuePayload* UMessage::mutable_value_payload() {
  set_has_value_payload();
  if (value_payload_ == NULL) {
    auto* p = CreateMaybeMessage<::ustore::ValuePayload>(GetArenaNoVirtual());
    value_payload_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ustore.UMessage.value_payload)
  return value_payload_;
}
inline void UMessage::set_allocated_value_payload(::ustore::ValuePayload* value_payload) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete value_payload_;
  }
  if (value_payload) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value_payload = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value_payload, submessage_arena);
    }
    set_has_value_payload();
  } else {
    clear_has_value_payload();
  }
  value_payload_ = value_payload;
  // @@protoc_insertion_point(field_set_allocated:ustore.UMessage.value_payload)
}

// optional .ustore.ResponsePayload response_payload = 12;
inline bool UMessage::has_response_payload() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UMessage::set_has_response_payload() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UMessage::clear_has_response_payload() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UMessage::clear_response_payload() {
  if (response_payload_ != NULL) response_payload_->Clear();
  clear_has_response_payload();
}
inline const ::ustore::ResponsePayload& UMessage::_internal_response_payload() const {
  return *response_payload_;
}
inline const ::ustore::ResponsePayload& UMessage::response_payload() const {
  const ::ustore::ResponsePayload* p = response_payload_;
  // @@protoc_insertion_point(field_get:ustore.UMessage.response_payload)
  return p != NULL ? *p : *reinterpret_cast<const ::ustore::ResponsePayload*>(
      &::ustore::_ResponsePayload_default_instance_);
}
inline ::ustore::ResponsePayload* UMessage::release_response_payload() {
  // @@protoc_insertion_point(field_release:ustore.UMessage.response_payload)
  clear_has_response_payload();
  ::ustore::ResponsePayload* temp = response_payload_;
  response_payload_ = NULL;
  return temp;
}
inline ::ustore::ResponsePayload* UMessage::mutable_response_payload() {
  set_has_response_payload();
  if (response_payload_ == NULL) {
    auto* p = CreateMaybeMessage<::ustore::ResponsePayload>(GetArenaNoVirtual());
    response_payload_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ustore.UMessage.response_payload)
  return response_payload_;
}
inline void UMessage::set_allocated_response_payload(::ustore::ResponsePayload* response_payload) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete response_payload_;
  }
  if (response_payload) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      response_payload = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, response_payload, submessage_arena);
    }
    set_has_response_payload();
  } else {
    clear_has_response_payload();
  }
  response_payload_ = response_payload;
  // @@protoc_insertion_point(field_set_allocated:ustore.UMessage.response_payload)
}

// optional .ustore.InfoPayload info_payload = 13;
inline bool UMessage::has_info_payload() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UMessage::set_has_info_payload() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UMessage::clear_has_info_payload() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UMessage::clear_info_payload() {
  if (info_payload_ != NULL) info_payload_->Clear();
  clear_has_info_payload();
}
inline const ::ustore::InfoPayload& UMessage::_internal_info_payload() const {
  return *info_payload_;
}
inline const ::ustore::InfoPayload& UMessage::info_payload() const {
  const ::ustore::InfoPayload* p = info_payload_;
  // @@protoc_insertion_point(field_get:ustore.UMessage.info_payload)
  return p != NULL ? *p : *reinterpret_cast<const ::ustore::InfoPayload*>(
      &::ustore::_InfoPayload_default_instance_);
}
inline ::ustore::InfoPayload* UMessage::release_info_payload() {
  // @@protoc_insertion_point(field_release:ustore.UMessage.info_payload)
  clear_has_info_payload();
  ::ustore::InfoPayload* temp = info_payload_;
  info_payload_ = NULL;
  return temp;
}
inline ::ustore::InfoPayload* UMessage::mutable_info_payload() {
  set_has_info_payload();
  if (info_payload_ == NULL) {
    auto* p = CreateMaybeMessage<::ustore::InfoPayload>(GetArenaNoVirtual());
    info_payload_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ustore.UMessage.info_payload)
  return info_payload_;
}
inline void UMessage::set_allocated_info_payload(::ustore::InfoPayload* info_payload) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete info_payload_;
  }
  if (info_payload) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      info_payload = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, info_payload, submessage_arena);
    }
    set_has_info_payload();
  } else {
    clear_has_info_payload();
  }
  info_payload_ = info_payload;
  // @@protoc_insertion_point(field_set_allocated:ustore.UMessage.info_payload)
}

// -------------------------------------------------------------------

// RequestPayload

// optional bytes key = 1;
inline bool RequestPayload::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestPayload::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestPayload::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestPayload::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& RequestPayload::key() const {
  // @@protoc_insertion_point(field_get:ustore.RequestPayload.key)
  return key_.GetNoArena();
}
inline void RequestPayload::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ustore.RequestPayload.key)
}
#if LANG_CXX11
inline void RequestPayload::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ustore.RequestPayload.key)
}
#endif
inline void RequestPayload::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ustore.RequestPayload.key)
}
inline void RequestPayload::set_key(const void* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ustore.RequestPayload.key)
}
inline ::std::string* RequestPayload::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:ustore.RequestPayload.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestPayload::release_key() {
  // @@protoc_insertion_point(field_release:ustore.RequestPayload.key)
  if (!has_key()) {
    return NULL;
  }
  clear_has_key();
  return key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestPayload::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:ustore.RequestPayload.key)
}

// optional bytes version = 2;
inline bool RequestPayload::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestPayload::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestPayload::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestPayload::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_version();
}
inline const ::std::string& RequestPayload::version() const {
  // @@protoc_insertion_point(field_get:ustore.RequestPayload.version)
  return version_.GetNoArena();
}
inline void RequestPayload::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ustore.RequestPayload.version)
}
#if LANG_CXX11
inline void RequestPayload::set_version(::std::string&& value) {
  set_has_version();
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ustore.RequestPayload.version)
}
#endif
inline void RequestPayload::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ustore.RequestPayload.version)
}
inline void RequestPayload::set_version(const void* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ustore.RequestPayload.version)
}
inline ::std::string* RequestPayload::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:ustore.RequestPayload.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestPayload::release_version() {
  // @@protoc_insertion_point(field_release:ustore.RequestPayload.version)
  if (!has_version()) {
    return NULL;
  }
  clear_has_version();
  return version_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestPayload::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:ustore.RequestPayload.version)
}

// optional bytes branch = 3;
inline bool RequestPayload::has_branch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestPayload::set_has_branch() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestPayload::clear_has_branch() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestPayload::clear_branch() {
  branch_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_branch();
}
inline const ::std::string& RequestPayload::branch() const {
  // @@protoc_insertion_point(field_get:ustore.RequestPayload.branch)
  return branch_.GetNoArena();
}
inline void RequestPayload::set_branch(const ::std::string& value) {
  set_has_branch();
  branch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ustore.RequestPayload.branch)
}
#if LANG_CXX11
inline void RequestPayload::set_branch(::std::string&& value) {
  set_has_branch();
  branch_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ustore.RequestPayload.branch)
}
#endif
inline void RequestPayload::set_branch(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_branch();
  branch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ustore.RequestPayload.branch)
}
inline void RequestPayload::set_branch(const void* value, size_t size) {
  set_has_branch();
  branch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ustore.RequestPayload.branch)
}
inline ::std::string* RequestPayload::mutable_branch() {
  set_has_branch();
  // @@protoc_insertion_point(field_mutable:ustore.RequestPayload.branch)
  return branch_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestPayload::release_branch() {
  // @@protoc_insertion_point(field_release:ustore.RequestPayload.branch)
  if (!has_branch()) {
    return NULL;
  }
  clear_has_branch();
  return branch_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestPayload::set_allocated_branch(::std::string* branch) {
  if (branch != NULL) {
    set_has_branch();
  } else {
    clear_has_branch();
  }
  branch_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), branch);
  // @@protoc_insertion_point(field_set_allocated:ustore.RequestPayload.branch)
}

// optional bytes ref_version = 4;
inline bool RequestPayload::has_ref_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestPayload::set_has_ref_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestPayload::clear_has_ref_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestPayload::clear_ref_version() {
  ref_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ref_version();
}
inline const ::std::string& RequestPayload::ref_version() const {
  // @@protoc_insertion_point(field_get:ustore.RequestPayload.ref_version)
  return ref_version_.GetNoArena();
}
inline void RequestPayload::set_ref_version(const ::std::string& value) {
  set_has_ref_version();
  ref_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ustore.RequestPayload.ref_version)
}
#if LANG_CXX11
inline void RequestPayload::set_ref_version(::std::string&& value) {
  set_has_ref_version();
  ref_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ustore.RequestPayload.ref_version)
}
#endif
inline void RequestPayload::set_ref_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ref_version();
  ref_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ustore.RequestPayload.ref_version)
}
inline void RequestPayload::set_ref_version(const void* value, size_t size) {
  set_has_ref_version();
  ref_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ustore.RequestPayload.ref_version)
}
inline ::std::string* RequestPayload::mutable_ref_version() {
  set_has_ref_version();
  // @@protoc_insertion_point(field_mutable:ustore.RequestPayload.ref_version)
  return ref_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestPayload::release_ref_version() {
  // @@protoc_insertion_point(field_release:ustore.RequestPayload.ref_version)
  if (!has_ref_version()) {
    return NULL;
  }
  clear_has_ref_version();
  return ref_version_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestPayload::set_allocated_ref_version(::std::string* ref_version) {
  if (ref_version != NULL) {
    set_has_ref_version();
  } else {
    clear_has_ref_version();
  }
  ref_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ref_version);
  // @@protoc_insertion_point(field_set_allocated:ustore.RequestPayload.ref_version)
}

// optional bytes ref_branch = 5;
inline bool RequestPayload::has_ref_branch() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestPayload::set_has_ref_branch() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestPayload::clear_has_ref_branch() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestPayload::clear_ref_branch() {
  ref_branch_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ref_branch();
}
inline const ::std::string& RequestPayload::ref_branch() const {
  // @@protoc_insertion_point(field_get:ustore.RequestPayload.ref_branch)
  return ref_branch_.GetNoArena();
}
inline void RequestPayload::set_ref_branch(const ::std::string& value) {
  set_has_ref_branch();
  ref_branch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ustore.RequestPayload.ref_branch)
}
#if LANG_CXX11
inline void RequestPayload::set_ref_branch(::std::string&& value) {
  set_has_ref_branch();
  ref_branch_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ustore.RequestPayload.ref_branch)
}
#endif
inline void RequestPayload::set_ref_branch(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ref_branch();
  ref_branch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ustore.RequestPayload.ref_branch)
}
inline void RequestPayload::set_ref_branch(const void* value, size_t size) {
  set_has_ref_branch();
  ref_branch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ustore.RequestPayload.ref_branch)
}
inline ::std::string* RequestPayload::mutable_ref_branch() {
  set_has_ref_branch();
  // @@protoc_insertion_point(field_mutable:ustore.RequestPayload.ref_branch)
  return ref_branch_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestPayload::release_ref_branch() {
  // @@protoc_insertion_point(field_release:ustore.RequestPayload.ref_branch)
  if (!has_ref_branch()) {
    return NULL;
  }
  clear_has_ref_branch();
  return ref_branch_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestPayload::set_allocated_ref_branch(::std::string* ref_branch) {
  if (ref_branch != NULL) {
    set_has_ref_branch();
  } else {
    clear_has_ref_branch();
  }
  ref_branch_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ref_branch);
  // @@protoc_insertion_point(field_set_allocated:ustore.RequestPayload.ref_branch)
}

// -------------------------------------------------------------------

// ValuePayload

// optional int32 type = 1;
inline bool ValuePayload::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ValuePayload::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ValuePayload::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ValuePayload::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ValuePayload::type() const {
  // @@protoc_insertion_point(field_get:ustore.ValuePayload.type)
  return type_;
}
inline void ValuePayload::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ustore.ValuePayload.type)
}

// optional bytes base = 2;
inline bool ValuePayload::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ValuePayload::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ValuePayload::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ValuePayload::clear_base() {
  base_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_base();
}
inline const ::std::string& ValuePayload::base() const {
  // @@protoc_insertion_point(field_get:ustore.ValuePayload.base)
  return base_.GetNoArena();
}
inline void ValuePayload::set_base(const ::std::string& value) {
  set_has_base();
  base_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ustore.ValuePayload.base)
}
#if LANG_CXX11
inline void ValuePayload::set_base(::std::string&& value) {
  set_has_base();
  base_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ustore.ValuePayload.base)
}
#endif
inline void ValuePayload::set_base(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_base();
  base_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ustore.ValuePayload.base)
}
inline void ValuePayload::set_base(const void* value, size_t size) {
  set_has_base();
  base_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ustore.ValuePayload.base)
}
inline ::std::string* ValuePayload::mutable_base() {
  set_has_base();
  // @@protoc_insertion_point(field_mutable:ustore.ValuePayload.base)
  return base_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ValuePayload::release_base() {
  // @@protoc_insertion_point(field_release:ustore.ValuePayload.base)
  if (!has_base()) {
    return NULL;
  }
  clear_has_base();
  return base_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ValuePayload::set_allocated_base(::std::string* base) {
  if (base != NULL) {
    set_has_base();
  } else {
    clear_has_base();
  }
  base_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), base);
  // @@protoc_insertion_point(field_set_allocated:ustore.ValuePayload.base)
}

// optional int32 pos = 3;
inline bool ValuePayload::has_pos() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ValuePayload::set_has_pos() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ValuePayload::clear_has_pos() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ValuePayload::clear_pos() {
  pos_ = 0;
  clear_has_pos();
}
inline ::google::protobuf::int32 ValuePayload::pos() const {
  // @@protoc_insertion_point(field_get:ustore.ValuePayload.pos)
  return pos_;
}
inline void ValuePayload::set_pos(::google::protobuf::int32 value) {
  set_has_pos();
  pos_ = value;
  // @@protoc_insertion_point(field_set:ustore.ValuePayload.pos)
}

// optional int32 dels = 4;
inline bool ValuePayload::has_dels() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ValuePayload::set_has_dels() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ValuePayload::clear_has_dels() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ValuePayload::clear_dels() {
  dels_ = 0;
  clear_has_dels();
}
inline ::google::protobuf::int32 ValuePayload::dels() const {
  // @@protoc_insertion_point(field_get:ustore.ValuePayload.dels)
  return dels_;
}
inline void ValuePayload::set_dels(::google::protobuf::int32 value) {
  set_has_dels();
  dels_ = value;
  // @@protoc_insertion_point(field_set:ustore.ValuePayload.dels)
}

// repeated bytes values = 5;
inline int ValuePayload::values_size() const {
  return values_.size();
}
inline void ValuePayload::clear_values() {
  values_.Clear();
}
inline const ::std::string& ValuePayload::values(int index) const {
  // @@protoc_insertion_point(field_get:ustore.ValuePayload.values)
  return values_.Get(index);
}
inline ::std::string* ValuePayload::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:ustore.ValuePayload.values)
  return values_.Mutable(index);
}
inline void ValuePayload::set_values(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ustore.ValuePayload.values)
  values_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ValuePayload::set_values(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ustore.ValuePayload.values)
  values_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ValuePayload::set_values(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ustore.ValuePayload.values)
}
inline void ValuePayload::set_values(int index, const void* value, size_t size) {
  values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ustore.ValuePayload.values)
}
inline ::std::string* ValuePayload::add_values() {
  // @@protoc_insertion_point(field_add_mutable:ustore.ValuePayload.values)
  return values_.Add();
}
inline void ValuePayload::add_values(const ::std::string& value) {
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ustore.ValuePayload.values)
}
#if LANG_CXX11
inline void ValuePayload::add_values(::std::string&& value) {
  values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ustore.ValuePayload.values)
}
#endif
inline void ValuePayload::add_values(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ustore.ValuePayload.values)
}
inline void ValuePayload::add_values(const void* value, size_t size) {
  values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ustore.ValuePayload.values)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ValuePayload::values() const {
  // @@protoc_insertion_point(field_list:ustore.ValuePayload.values)
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ValuePayload::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:ustore.ValuePayload.values)
  return &values_;
}

// repeated bytes keys = 6;
inline int ValuePayload::keys_size() const {
  return keys_.size();
}
inline void ValuePayload::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& ValuePayload::keys(int index) const {
  // @@protoc_insertion_point(field_get:ustore.ValuePayload.keys)
  return keys_.Get(index);
}
inline ::std::string* ValuePayload::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:ustore.ValuePayload.keys)
  return keys_.Mutable(index);
}
inline void ValuePayload::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ustore.ValuePayload.keys)
  keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ValuePayload::set_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ustore.ValuePayload.keys)
  keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ValuePayload::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ustore.ValuePayload.keys)
}
inline void ValuePayload::set_keys(int index, const void* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ustore.ValuePayload.keys)
}
inline ::std::string* ValuePayload::add_keys() {
  // @@protoc_insertion_point(field_add_mutable:ustore.ValuePayload.keys)
  return keys_.Add();
}
inline void ValuePayload::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ustore.ValuePayload.keys)
}
#if LANG_CXX11
inline void ValuePayload::add_keys(::std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ustore.ValuePayload.keys)
}
#endif
inline void ValuePayload::add_keys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ustore.ValuePayload.keys)
}
inline void ValuePayload::add_keys(const void* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ustore.ValuePayload.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ValuePayload::keys() const {
  // @@protoc_insertion_point(field_list:ustore.ValuePayload.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ValuePayload::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:ustore.ValuePayload.keys)
  return &keys_;
}

// optional bytes ctx = 10;
inline bool ValuePayload::has_ctx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ValuePayload::set_has_ctx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ValuePayload::clear_has_ctx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ValuePayload::clear_ctx() {
  ctx_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ctx();
}
inline const ::std::string& ValuePayload::ctx() const {
  // @@protoc_insertion_point(field_get:ustore.ValuePayload.ctx)
  return ctx_.GetNoArena();
}
inline void ValuePayload::set_ctx(const ::std::string& value) {
  set_has_ctx();
  ctx_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ustore.ValuePayload.ctx)
}
#if LANG_CXX11
inline void ValuePayload::set_ctx(::std::string&& value) {
  set_has_ctx();
  ctx_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ustore.ValuePayload.ctx)
}
#endif
inline void ValuePayload::set_ctx(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ctx();
  ctx_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ustore.ValuePayload.ctx)
}
inline void ValuePayload::set_ctx(const void* value, size_t size) {
  set_has_ctx();
  ctx_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ustore.ValuePayload.ctx)
}
inline ::std::string* ValuePayload::mutable_ctx() {
  set_has_ctx();
  // @@protoc_insertion_point(field_mutable:ustore.ValuePayload.ctx)
  return ctx_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ValuePayload::release_ctx() {
  // @@protoc_insertion_point(field_release:ustore.ValuePayload.ctx)
  if (!has_ctx()) {
    return NULL;
  }
  clear_has_ctx();
  return ctx_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ValuePayload::set_allocated_ctx(::std::string* ctx) {
  if (ctx != NULL) {
    set_has_ctx();
  } else {
    clear_has_ctx();
  }
  ctx_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ctx);
  // @@protoc_insertion_point(field_set_allocated:ustore.ValuePayload.ctx)
}

// -------------------------------------------------------------------

// ResponsePayload

// required int32 stat = 1;
inline bool ResponsePayload::has_stat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponsePayload::set_has_stat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponsePayload::clear_has_stat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponsePayload::clear_stat() {
  stat_ = 0;
  clear_has_stat();
}
inline ::google::protobuf::int32 ResponsePayload::stat() const {
  // @@protoc_insertion_point(field_get:ustore.ResponsePayload.stat)
  return stat_;
}
inline void ResponsePayload::set_stat(::google::protobuf::int32 value) {
  set_has_stat();
  stat_ = value;
  // @@protoc_insertion_point(field_set:ustore.ResponsePayload.stat)
}

// optional bytes value = 2;
inline bool ResponsePayload::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponsePayload::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponsePayload::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponsePayload::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& ResponsePayload::value() const {
  // @@protoc_insertion_point(field_get:ustore.ResponsePayload.value)
  return value_.GetNoArena();
}
inline void ResponsePayload::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ustore.ResponsePayload.value)
}
#if LANG_CXX11
inline void ResponsePayload::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ustore.ResponsePayload.value)
}
#endif
inline void ResponsePayload::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ustore.ResponsePayload.value)
}
inline void ResponsePayload::set_value(const void* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ustore.ResponsePayload.value)
}
inline ::std::string* ResponsePayload::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:ustore.ResponsePayload.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponsePayload::release_value() {
  // @@protoc_insertion_point(field_release:ustore.ResponsePayload.value)
  if (!has_value()) {
    return NULL;
  }
  clear_has_value();
  return value_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponsePayload::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:ustore.ResponsePayload.value)
}

// optional bool bvalue = 3;
inline bool ResponsePayload::has_bvalue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponsePayload::set_has_bvalue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponsePayload::clear_has_bvalue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponsePayload::clear_bvalue() {
  bvalue_ = false;
  clear_has_bvalue();
}
inline bool ResponsePayload::bvalue() const {
  // @@protoc_insertion_point(field_get:ustore.ResponsePayload.bvalue)
  return bvalue_;
}
inline void ResponsePayload::set_bvalue(bool value) {
  set_has_bvalue();
  bvalue_ = value;
  // @@protoc_insertion_point(field_set:ustore.ResponsePayload.bvalue)
}

// repeated bytes lvalue = 4;
inline int ResponsePayload::lvalue_size() const {
  return lvalue_.size();
}
inline void ResponsePayload::clear_lvalue() {
  lvalue_.Clear();
}
inline const ::std::string& ResponsePayload::lvalue(int index) const {
  // @@protoc_insertion_point(field_get:ustore.ResponsePayload.lvalue)
  return lvalue_.Get(index);
}
inline ::std::string* ResponsePayload::mutable_lvalue(int index) {
  // @@protoc_insertion_point(field_mutable:ustore.ResponsePayload.lvalue)
  return lvalue_.Mutable(index);
}
inline void ResponsePayload::set_lvalue(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ustore.ResponsePayload.lvalue)
  lvalue_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ResponsePayload::set_lvalue(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ustore.ResponsePayload.lvalue)
  lvalue_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ResponsePayload::set_lvalue(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  lvalue_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ustore.ResponsePayload.lvalue)
}
inline void ResponsePayload::set_lvalue(int index, const void* value, size_t size) {
  lvalue_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ustore.ResponsePayload.lvalue)
}
inline ::std::string* ResponsePayload::add_lvalue() {
  // @@protoc_insertion_point(field_add_mutable:ustore.ResponsePayload.lvalue)
  return lvalue_.Add();
}
inline void ResponsePayload::add_lvalue(const ::std::string& value) {
  lvalue_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ustore.ResponsePayload.lvalue)
}
#if LANG_CXX11
inline void ResponsePayload::add_lvalue(::std::string&& value) {
  lvalue_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ustore.ResponsePayload.lvalue)
}
#endif
inline void ResponsePayload::add_lvalue(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  lvalue_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ustore.ResponsePayload.lvalue)
}
inline void ResponsePayload::add_lvalue(const void* value, size_t size) {
  lvalue_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ustore.ResponsePayload.lvalue)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ResponsePayload::lvalue() const {
  // @@protoc_insertion_point(field_list:ustore.ResponsePayload.lvalue)
  return lvalue_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ResponsePayload::mutable_lvalue() {
  // @@protoc_insertion_point(field_mutable_list:ustore.ResponsePayload.lvalue)
  return &lvalue_;
}

// -------------------------------------------------------------------

// InfoPayload

// required bytes node_id = 20;
inline bool InfoPayload::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InfoPayload::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InfoPayload::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InfoPayload::clear_node_id() {
  node_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_node_id();
}
inline const ::std::string& InfoPayload::node_id() const {
  // @@protoc_insertion_point(field_get:ustore.InfoPayload.node_id)
  return node_id_.GetNoArena();
}
inline void InfoPayload::set_node_id(const ::std::string& value) {
  set_has_node_id();
  node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ustore.InfoPayload.node_id)
}
#if LANG_CXX11
inline void InfoPayload::set_node_id(::std::string&& value) {
  set_has_node_id();
  node_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ustore.InfoPayload.node_id)
}
#endif
inline void InfoPayload::set_node_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_node_id();
  node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ustore.InfoPayload.node_id)
}
inline void InfoPayload::set_node_id(const void* value, size_t size) {
  set_has_node_id();
  node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ustore.InfoPayload.node_id)
}
inline ::std::string* InfoPayload::mutable_node_id() {
  set_has_node_id();
  // @@protoc_insertion_point(field_mutable:ustore.InfoPayload.node_id)
  return node_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InfoPayload::release_node_id() {
  // @@protoc_insertion_point(field_release:ustore.InfoPayload.node_id)
  if (!has_node_id()) {
    return NULL;
  }
  clear_has_node_id();
  return node_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InfoPayload::set_allocated_node_id(::std::string* node_id) {
  if (node_id != NULL) {
    set_has_node_id();
  } else {
    clear_has_node_id();
  }
  node_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), node_id);
  // @@protoc_insertion_point(field_set_allocated:ustore.InfoPayload.node_id)
}

// required int64 chunks = 1;
inline bool InfoPayload::has_chunks() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InfoPayload::set_has_chunks() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InfoPayload::clear_has_chunks() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InfoPayload::clear_chunks() {
  chunks_ = GOOGLE_LONGLONG(0);
  clear_has_chunks();
}
inline ::google::protobuf::int64 InfoPayload::chunks() const {
  // @@protoc_insertion_point(field_get:ustore.InfoPayload.chunks)
  return chunks_;
}
inline void InfoPayload::set_chunks(::google::protobuf::int64 value) {
  set_has_chunks();
  chunks_ = value;
  // @@protoc_insertion_point(field_set:ustore.InfoPayload.chunks)
}

// required int64 chunk_bytes = 2;
inline bool InfoPayload::has_chunk_bytes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InfoPayload::set_has_chunk_bytes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InfoPayload::clear_has_chunk_bytes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InfoPayload::clear_chunk_bytes() {
  chunk_bytes_ = GOOGLE_LONGLONG(0);
  clear_has_chunk_bytes();
}
inline ::google::protobuf::int64 InfoPayload::chunk_bytes() const {
  // @@protoc_insertion_point(field_get:ustore.InfoPayload.chunk_bytes)
  return chunk_bytes_;
}
inline void InfoPayload::set_chunk_bytes(::google::protobuf::int64 value) {
  set_has_chunk_bytes();
  chunk_bytes_ = value;
  // @@protoc_insertion_point(field_set:ustore.InfoPayload.chunk_bytes)
}

// required int64 valid_chunks = 3;
inline bool InfoPayload::has_valid_chunks() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InfoPayload::set_has_valid_chunks() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InfoPayload::clear_has_valid_chunks() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InfoPayload::clear_valid_chunks() {
  valid_chunks_ = GOOGLE_LONGLONG(0);
  clear_has_valid_chunks();
}
inline ::google::protobuf::int64 InfoPayload::valid_chunks() const {
  // @@protoc_insertion_point(field_get:ustore.InfoPayload.valid_chunks)
  return valid_chunks_;
}
inline void InfoPayload::set_valid_chunks(::google::protobuf::int64 value) {
  set_has_valid_chunks();
  valid_chunks_ = value;
  // @@protoc_insertion_point(field_set:ustore.InfoPayload.valid_chunks)
}

// required int64 valid_chunk_bytes = 4;
inline bool InfoPayload::has_valid_chunk_bytes() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InfoPayload::set_has_valid_chunk_bytes() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InfoPayload::clear_has_valid_chunk_bytes() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InfoPayload::clear_valid_chunk_bytes() {
  valid_chunk_bytes_ = GOOGLE_LONGLONG(0);
  clear_has_valid_chunk_bytes();
}
inline ::google::protobuf::int64 InfoPayload::valid_chunk_bytes() const {
  // @@protoc_insertion_point(field_get:ustore.InfoPayload.valid_chunk_bytes)
  return valid_chunk_bytes_;
}
inline void InfoPayload::set_valid_chunk_bytes(::google::protobuf::int64 value) {
  set_has_valid_chunk_bytes();
  valid_chunk_bytes_ = value;
  // @@protoc_insertion_point(field_set:ustore.InfoPayload.valid_chunk_bytes)
}

// required int64 max_segments = 5;
inline bool InfoPayload::has_max_segments() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InfoPayload::set_has_max_segments() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InfoPayload::clear_has_max_segments() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InfoPayload::clear_max_segments() {
  max_segments_ = GOOGLE_LONGLONG(0);
  clear_has_max_segments();
}
inline ::google::protobuf::int64 InfoPayload::max_segments() const {
  // @@protoc_insertion_point(field_get:ustore.InfoPayload.max_segments)
  return max_segments_;
}
inline void InfoPayload::set_max_segments(::google::protobuf::int64 value) {
  set_has_max_segments();
  max_segments_ = value;
  // @@protoc_insertion_point(field_set:ustore.InfoPayload.max_segments)
}

// required int64 alloc_segments = 6;
inline bool InfoPayload::has_alloc_segments() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InfoPayload::set_has_alloc_segments() {
  _has_bits_[0] |= 0x00000040u;
}
inline void InfoPayload::clear_has_alloc_segments() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void InfoPayload::clear_alloc_segments() {
  alloc_segments_ = GOOGLE_LONGLONG(0);
  clear_has_alloc_segments();
}
inline ::google::protobuf::int64 InfoPayload::alloc_segments() const {
  // @@protoc_insertion_point(field_get:ustore.InfoPayload.alloc_segments)
  return alloc_segments_;
}
inline void InfoPayload::set_alloc_segments(::google::protobuf::int64 value) {
  set_has_alloc_segments();
  alloc_segments_ = value;
  // @@protoc_insertion_point(field_set:ustore.InfoPayload.alloc_segments)
}

// required int64 free_segments = 7;
inline bool InfoPayload::has_free_segments() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void InfoPayload::set_has_free_segments() {
  _has_bits_[0] |= 0x00000080u;
}
inline void InfoPayload::clear_has_free_segments() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void InfoPayload::clear_free_segments() {
  free_segments_ = GOOGLE_LONGLONG(0);
  clear_has_free_segments();
}
inline ::google::protobuf::int64 InfoPayload::free_segments() const {
  // @@protoc_insertion_point(field_get:ustore.InfoPayload.free_segments)
  return free_segments_;
}
inline void InfoPayload::set_free_segments(::google::protobuf::int64 value) {
  set_has_free_segments();
  free_segments_ = value;
  // @@protoc_insertion_point(field_set:ustore.InfoPayload.free_segments)
}

// required int64 used_segments = 8;
inline bool InfoPayload::has_used_segments() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void InfoPayload::set_has_used_segments() {
  _has_bits_[0] |= 0x00000100u;
}
inline void InfoPayload::clear_has_used_segments() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void InfoPayload::clear_used_segments() {
  used_segments_ = GOOGLE_LONGLONG(0);
  clear_has_used_segments();
}
inline ::google::protobuf::int64 InfoPayload::used_segments() const {
  // @@protoc_insertion_point(field_get:ustore.InfoPayload.used_segments)
  return used_segments_;
}
inline void InfoPayload::set_used_segments(::google::protobuf::int64 value) {
  set_has_used_segments();
  used_segments_ = value;
  // @@protoc_insertion_point(field_set:ustore.InfoPayload.used_segments)
}

// repeated int32 chunk_types = 10;
inline int InfoPayload::chunk_types_size() const {
  return chunk_types_.size();
}
inline void InfoPayload::clear_chunk_types() {
  chunk_types_.Clear();
}
inline ::google::protobuf::int32 InfoPayload::chunk_types(int index) const {
  // @@protoc_insertion_point(field_get:ustore.InfoPayload.chunk_types)
  return chunk_types_.Get(index);
}
inline void InfoPayload::set_chunk_types(int index, ::google::protobuf::int32 value) {
  chunk_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:ustore.InfoPayload.chunk_types)
}
inline void InfoPayload::add_chunk_types(::google::protobuf::int32 value) {
  chunk_types_.Add(value);
  // @@protoc_insertion_point(field_add:ustore.InfoPayload.chunk_types)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
InfoPayload::chunk_types() const {
  // @@protoc_insertion_point(field_list:ustore.InfoPayload.chunk_types)
  return chunk_types_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
InfoPayload::mutable_chunk_types() {
  // @@protoc_insertion_point(field_mutable_list:ustore.InfoPayload.chunk_types)
  return &chunk_types_;
}

// repeated int64 chunks_per_type = 11;
inline int InfoPayload::chunks_per_type_size() const {
  return chunks_per_type_.size();
}
inline void InfoPayload::clear_chunks_per_type() {
  chunks_per_type_.Clear();
}
inline ::google::protobuf::int64 InfoPayload::chunks_per_type(int index) const {
  // @@protoc_insertion_point(field_get:ustore.InfoPayload.chunks_per_type)
  return chunks_per_type_.Get(index);
}
inline void InfoPayload::set_chunks_per_type(int index, ::google::protobuf::int64 value) {
  chunks_per_type_.Set(index, value);
  // @@protoc_insertion_point(field_set:ustore.InfoPayload.chunks_per_type)
}
inline void InfoPayload::add_chunks_per_type(::google::protobuf::int64 value) {
  chunks_per_type_.Add(value);
  // @@protoc_insertion_point(field_add:ustore.InfoPayload.chunks_per_type)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
InfoPayload::chunks_per_type() const {
  // @@protoc_insertion_point(field_list:ustore.InfoPayload.chunks_per_type)
  return chunks_per_type_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
InfoPayload::mutable_chunks_per_type() {
  // @@protoc_insertion_point(field_mutable_list:ustore.InfoPayload.chunks_per_type)
  return &chunks_per_type_;
}

// repeated int64 bytes_per_type = 12;
inline int InfoPayload::bytes_per_type_size() const {
  return bytes_per_type_.size();
}
inline void InfoPayload::clear_bytes_per_type() {
  bytes_per_type_.Clear();
}
inline ::google::protobuf::int64 InfoPayload::bytes_per_type(int index) const {
  // @@protoc_insertion_point(field_get:ustore.InfoPayload.bytes_per_type)
  return bytes_per_type_.Get(index);
}
inline void InfoPayload::set_bytes_per_type(int index, ::google::protobuf::int64 value) {
  bytes_per_type_.Set(index, value);
  // @@protoc_insertion_point(field_set:ustore.InfoPayload.bytes_per_type)
}
inline void InfoPayload::add_bytes_per_type(::google::protobuf::int64 value) {
  bytes_per_type_.Add(value);
  // @@protoc_insertion_point(field_add:ustore.InfoPayload.bytes_per_type)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
InfoPayload::bytes_per_type() const {
  // @@protoc_insertion_point(field_list:ustore.InfoPayload.bytes_per_type)
  return bytes_per_type_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
InfoPayload::mutable_bytes_per_type() {
  // @@protoc_insertion_point(field_mutable_list:ustore.InfoPayload.bytes_per_type)
  return &bytes_per_type_;
}

// -------------------------------------------------------------------

// RangeRequest

// optional bytes key = 1;
inline bool RangeRequest::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RangeRequest::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RangeRequest::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RangeRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& RangeRequest::key() const {
  // @@protoc_insertion_point(field_get:ustore.RangeRequest.key)
  return key_.GetNoArena();
}
inline void RangeRequest::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ustore.RangeRequest.key)
}
#if LANG_CXX11
inline void RangeRequest::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ustore.RangeRequest.key)
}
#endif
inline void RangeRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ustore.RangeRequest.key)
}
inline void RangeRequest::set_key(const void* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ustore.RangeRequest.key)
}
inline ::std::string* RangeRequest::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:ustore.RangeRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RangeRequest::release_key() {
  // @@protoc_insertion_point(field_release:ustore.RangeRequest.key)
  if (!has_key()) {
    return NULL;
  }
  clear_has_key();
  return key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RangeRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:ustore.RangeRequest.key)
}

// -------------------------------------------------------------------

// RangeResponse

// repeated .ustore.RangeInfo range_map = 1;
inline int RangeResponse::range_map_size() const {
  return range_map_.size();
}
inline void RangeResponse::clear_range_map() {
  range_map_.Clear();
}
inline ::ustore::RangeInfo* RangeResponse::mutable_range_map(int index) {
  // @@protoc_insertion_point(field_mutable:ustore.RangeResponse.range_map)
  return range_map_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ustore::RangeInfo >*
RangeResponse::mutable_range_map() {
  // @@protoc_insertion_point(field_mutable_list:ustore.RangeResponse.range_map)
  return &range_map_;
}
inline const ::ustore::RangeInfo& RangeResponse::range_map(int index) const {
  // @@protoc_insertion_point(field_get:ustore.RangeResponse.range_map)
  return range_map_.Get(index);
}
inline ::ustore::RangeInfo* RangeResponse::add_range_map() {
  // @@protoc_insertion_point(field_add:ustore.RangeResponse.range_map)
  return range_map_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ustore::RangeInfo >&
RangeResponse::range_map() const {
  // @@protoc_insertion_point(field_list:ustore.RangeResponse.range_map)
  return range_map_;
}

// -------------------------------------------------------------------

// RangeInfo

// required bytes start = 1;
inline bool RangeInfo::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RangeInfo::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RangeInfo::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RangeInfo::clear_start() {
  start_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_start();
}
inline const ::std::string& RangeInfo::start() const {
  // @@protoc_insertion_point(field_get:ustore.RangeInfo.start)
  return start_.GetNoArena();
}
inline void RangeInfo::set_start(const ::std::string& value) {
  set_has_start();
  start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ustore.RangeInfo.start)
}
#if LANG_CXX11
inline void RangeInfo::set_start(::std::string&& value) {
  set_has_start();
  start_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ustore.RangeInfo.start)
}
#endif
inline void RangeInfo::set_start(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_start();
  start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ustore.RangeInfo.start)
}
inline void RangeInfo::set_start(const void* value, size_t size) {
  set_has_start();
  start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ustore.RangeInfo.start)
}
inline ::std::string* RangeInfo::mutable_start() {
  set_has_start();
  // @@protoc_insertion_point(field_mutable:ustore.RangeInfo.start)
  return start_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RangeInfo::release_start() {
  // @@protoc_insertion_point(field_release:ustore.RangeInfo.start)
  if (!has_start()) {
    return NULL;
  }
  clear_has_start();
  return start_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RangeInfo::set_allocated_start(::std::string* start) {
  if (start != NULL) {
    set_has_start();
  } else {
    clear_has_start();
  }
  start_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), start);
  // @@protoc_insertion_point(field_set_allocated:ustore.RangeInfo.start)
}

// optional bytes end = 2;
inline bool RangeInfo::has_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RangeInfo::set_has_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RangeInfo::clear_has_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RangeInfo::clear_end() {
  end_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_end();
}
inline const ::std::string& RangeInfo::end() const {
  // @@protoc_insertion_point(field_get:ustore.RangeInfo.end)
  return end_.GetNoArena();
}
inline void RangeInfo::set_end(const ::std::string& value) {
  set_has_end();
  end_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ustore.RangeInfo.end)
}
#if LANG_CXX11
inline void RangeInfo::set_end(::std::string&& value) {
  set_has_end();
  end_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ustore.RangeInfo.end)
}
#endif
inline void RangeInfo::set_end(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_end();
  end_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ustore.RangeInfo.end)
}
inline void RangeInfo::set_end(const void* value, size_t size) {
  set_has_end();
  end_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ustore.RangeInfo.end)
}
inline ::std::string* RangeInfo::mutable_end() {
  set_has_end();
  // @@protoc_insertion_point(field_mutable:ustore.RangeInfo.end)
  return end_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RangeInfo::release_end() {
  // @@protoc_insertion_point(field_release:ustore.RangeInfo.end)
  if (!has_end()) {
    return NULL;
  }
  clear_has_end();
  return end_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RangeInfo::set_allocated_end(::std::string* end) {
  if (end != NULL) {
    set_has_end();
  } else {
    clear_has_end();
  }
  end_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), end);
  // @@protoc_insertion_point(field_set_allocated:ustore.RangeInfo.end)
}

// required string address = 4;
inline bool RangeInfo::has_address() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RangeInfo::set_has_address() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RangeInfo::clear_has_address() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RangeInfo::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_address();
}
inline const ::std::string& RangeInfo::address() const {
  // @@protoc_insertion_point(field_get:ustore.RangeInfo.address)
  return address_.GetNoArena();
}
inline void RangeInfo::set_address(const ::std::string& value) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ustore.RangeInfo.address)
}
#if LANG_CXX11
inline void RangeInfo::set_address(::std::string&& value) {
  set_has_address();
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ustore.RangeInfo.address)
}
#endif
inline void RangeInfo::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ustore.RangeInfo.address)
}
inline void RangeInfo::set_address(const char* value, size_t size) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ustore.RangeInfo.address)
}
inline ::std::string* RangeInfo::mutable_address() {
  set_has_address();
  // @@protoc_insertion_point(field_mutable:ustore.RangeInfo.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RangeInfo::release_address() {
  // @@protoc_insertion_point(field_release:ustore.RangeInfo.address)
  if (!has_address()) {
    return NULL;
  }
  clear_has_address();
  return address_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RangeInfo::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    set_has_address();
  } else {
    clear_has_address();
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:ustore.RangeInfo.address)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ustore

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ustore::UMessage_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ustore::UMessage_Type>() {
  return ::ustore::UMessage_Type_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_messages_2eproto
