// Code generated by moq; DO NOT EDIT
// github.com/matryer/moq

package a2m

import (
	"sync"
)

var (
	lockA2MInterfaceMockAdvance                  sync.RWMutex
	lockA2MInterfaceMockAppend                   sync.RWMutex
	lockA2MInterfaceMockDestroyA2M               sync.RWMutex
	lockA2MInterfaceMockEnd                      sync.RWMutex
	lockA2MInterfaceMockGetMessage               sync.RWMutex
	lockA2MInterfaceMockLookup                   sync.RWMutex
	lockA2MInterfaceMockStartA2M                 sync.RWMutex
	lockA2MInterfaceMockTruncate                 sync.RWMutex
	lockA2MInterfaceMockVerifyAttestation        sync.RWMutex
	lockA2MInterfaceMockVerifyMessage            sync.RWMutex
	lockA2MInterfaceMockVerifySkippedAttestation sync.RWMutex
)

// A2MInterfaceMock is a mock implementation of A2MInterface.
//
//     func TestSomethingThatUsesA2MInterface(t *testing.T) {
//
//         // make and configure a mocked A2MInterface
//         mockedA2MInterface := &A2MInterfaceMock{
//             AdvanceFunc: func(logname string, n int, newdigest []byte, input []byte) ([]byte, error) {
// 	               panic("TODO: mock out the Advance method")
//             },
//             AppendFunc: func(logname string, input []byte) ([]byte, error) {
// 	               panic("TODO: mock out the Append method")
//             },
//             DestroyA2MFunc: func()  {
// 	               panic("TODO: mock out the DestroyA2M method")
//             },
//             EndFunc: func(logname string) ([]byte, error) {
// 	               panic("TODO: mock out the End method")
//             },
//             GetMessageFunc: func(attestation []byte) ([]byte, error) {
// 	               panic("TODO: mock out the GetMessage method")
//             },
//             LookupFunc: func(logname string, n int) ([]byte, error) {
// 	               panic("TODO: mock out the Lookup method")
//             },
//             StartA2MFunc: func()  {
// 	               panic("TODO: mock out the StartA2M method")
//             },
//             TruncateFunc: func(logname string, n int) error {
// 	               panic("TODO: mock out the Truncate method")
//             },
//             VerifyAttestationFunc: func(attestation []byte) (int, error) {
// 	               panic("TODO: mock out the VerifyAttestation method")
//             },
//             VerifyMessageFunc: func(message []byte, attestation []byte) (int, error) {
// 	               panic("TODO: mock out the VerifyMessage method")
//             },
//             VerifySkippedAttestationFunc: func(attestation []byte) (int, error) {
// 	               panic("TODO: mock out the VerifySkippedAttestation method")
//             },
//         }
//
//         // TODO: use mockedA2MInterface in code that requires A2MInterface
//         //       and then make assertions.
//
//     }
type A2MInterfaceMock struct {
	// AdvanceFunc mocks the Advance method.
	AdvanceFunc func(logname string, n int, newdigest []byte, input []byte) ([]byte, error)

	// AppendFunc mocks the Append method.
	AppendFunc func(logname string, input []byte) ([]byte, error)

	// DestroyA2MFunc mocks the DestroyA2M method.
	DestroyA2MFunc func()

	// EndFunc mocks the End method.
	EndFunc func(logname string) ([]byte, error)

	// GetMessageFunc mocks the GetMessage method.
	GetMessageFunc func(attestation []byte) ([]byte, error)

	// LookupFunc mocks the Lookup method.
	LookupFunc func(logname string, n int) ([]byte, error)

	// StartA2MFunc mocks the StartA2M method.
	StartA2MFunc func()

	// TruncateFunc mocks the Truncate method.
	TruncateFunc func(logname string, n int) error

	// VerifyAttestationFunc mocks the VerifyAttestation method.
	VerifyAttestationFunc func(attestation []byte) (int, error)

	// VerifyMessageFunc mocks the VerifyMessage method.
	VerifyMessageFunc func(message []byte, attestation []byte) (int, error)

	// VerifySkippedAttestationFunc mocks the VerifySkippedAttestation method.
	VerifySkippedAttestationFunc func(attestation []byte) (int, error)

	// calls tracks calls to the methods.
	calls struct {
		// Advance holds details about calls to the Advance method.
		Advance []struct {
			// Logname is the logname argument value.
			Logname string
			// N is the n argument value.
			N int
			// Newdigest is the newdigest argument value.
			Newdigest []byte
			// Input is the input argument value.
			Input []byte
		}
		// Append holds details about calls to the Append method.
		Append []struct {
			// Logname is the logname argument value.
			Logname string
			// Input is the input argument value.
			Input []byte
		}
		// DestroyA2M holds details about calls to the DestroyA2M method.
		DestroyA2M []struct {
		}
		// End holds details about calls to the End method.
		End []struct {
			// Logname is the logname argument value.
			Logname string
		}
		// GetMessage holds details about calls to the GetMessage method.
		GetMessage []struct {
			// Attestation is the attestation argument value.
			Attestation []byte
		}
		// Lookup holds details about calls to the Lookup method.
		Lookup []struct {
			// Logname is the logname argument value.
			Logname string
			// N is the n argument value.
			N int
		}
		// StartA2M holds details about calls to the StartA2M method.
		StartA2M []struct {
		}
		// Truncate holds details about calls to the Truncate method.
		Truncate []struct {
			// Logname is the logname argument value.
			Logname string
			// N is the n argument value.
			N int
		}
		// VerifyAttestation holds details about calls to the VerifyAttestation method.
		VerifyAttestation []struct {
			// Attestation is the attestation argument value.
			Attestation []byte
		}
		// VerifyMessage holds details about calls to the VerifyMessage method.
		VerifyMessage []struct {
			// Message is the message argument value.
			Message []byte
			// Attestation is the attestation argument value.
			Attestation []byte
		}
		// VerifySkippedAttestation holds details about calls to the VerifySkippedAttestation method.
		VerifySkippedAttestation []struct {
			// Attestation is the attestation argument value.
			Attestation []byte
		}
	}
}

// Advance calls AdvanceFunc.
func (mock *A2MInterfaceMock) Advance(logname string, n int, newdigest []byte, input []byte) ([]byte, error) {
	if mock.AdvanceFunc == nil {
		panic("moq: A2MInterfaceMock.AdvanceFunc is nil but A2MInterface.Advance was just called")
	}
	callInfo := struct {
		Logname   string
		N         int
		Newdigest []byte
		Input     []byte
	}{
		Logname:   logname,
		N:         n,
		Newdigest: newdigest,
		Input:     input,
	}
	lockA2MInterfaceMockAdvance.Lock()
	mock.calls.Advance = append(mock.calls.Advance, callInfo)
	lockA2MInterfaceMockAdvance.Unlock()
	return mock.AdvanceFunc(logname, n, newdigest, input)
}

// AdvanceCalls gets all the calls that were made to Advance.
// Check the length with:
//     len(mockedA2MInterface.AdvanceCalls())
func (mock *A2MInterfaceMock) AdvanceCalls() []struct {
	Logname   string
	N         int
	Newdigest []byte
	Input     []byte
} {
	var calls []struct {
		Logname   string
		N         int
		Newdigest []byte
		Input     []byte
	}
	lockA2MInterfaceMockAdvance.RLock()
	calls = mock.calls.Advance
	lockA2MInterfaceMockAdvance.RUnlock()
	return calls
}

// Append calls AppendFunc.
func (mock *A2MInterfaceMock) Append(logname string, input []byte) ([]byte, error) {
	if mock.AppendFunc == nil {
		panic("moq: A2MInterfaceMock.AppendFunc is nil but A2MInterface.Append was just called")
	}
	callInfo := struct {
		Logname string
		Input   []byte
	}{
		Logname: logname,
		Input:   input,
	}
	lockA2MInterfaceMockAppend.Lock()
	mock.calls.Append = append(mock.calls.Append, callInfo)
	lockA2MInterfaceMockAppend.Unlock()
	return mock.AppendFunc(logname, input)
}

// AppendCalls gets all the calls that were made to Append.
// Check the length with:
//     len(mockedA2MInterface.AppendCalls())
func (mock *A2MInterfaceMock) AppendCalls() []struct {
	Logname string
	Input   []byte
} {
	var calls []struct {
		Logname string
		Input   []byte
	}
	lockA2MInterfaceMockAppend.RLock()
	calls = mock.calls.Append
	lockA2MInterfaceMockAppend.RUnlock()
	return calls
}

// DestroyA2M calls DestroyA2MFunc.
func (mock *A2MInterfaceMock) DestroyA2M() {
	if mock.DestroyA2MFunc == nil {
		panic("moq: A2MInterfaceMock.DestroyA2MFunc is nil but A2MInterface.DestroyA2M was just called")
	}
	callInfo := struct {
	}{}
	lockA2MInterfaceMockDestroyA2M.Lock()
	mock.calls.DestroyA2M = append(mock.calls.DestroyA2M, callInfo)
	lockA2MInterfaceMockDestroyA2M.Unlock()
	mock.DestroyA2MFunc()
}

// DestroyA2MCalls gets all the calls that were made to DestroyA2M.
// Check the length with:
//     len(mockedA2MInterface.DestroyA2MCalls())
func (mock *A2MInterfaceMock) DestroyA2MCalls() []struct {
} {
	var calls []struct {
	}
	lockA2MInterfaceMockDestroyA2M.RLock()
	calls = mock.calls.DestroyA2M
	lockA2MInterfaceMockDestroyA2M.RUnlock()
	return calls
}

// End calls EndFunc.
func (mock *A2MInterfaceMock) End(logname string) ([]byte, error) {
	if mock.EndFunc == nil {
		panic("moq: A2MInterfaceMock.EndFunc is nil but A2MInterface.End was just called")
	}
	callInfo := struct {
		Logname string
	}{
		Logname: logname,
	}
	lockA2MInterfaceMockEnd.Lock()
	mock.calls.End = append(mock.calls.End, callInfo)
	lockA2MInterfaceMockEnd.Unlock()
	return mock.EndFunc(logname)
}

// EndCalls gets all the calls that were made to End.
// Check the length with:
//     len(mockedA2MInterface.EndCalls())
func (mock *A2MInterfaceMock) EndCalls() []struct {
	Logname string
} {
	var calls []struct {
		Logname string
	}
	lockA2MInterfaceMockEnd.RLock()
	calls = mock.calls.End
	lockA2MInterfaceMockEnd.RUnlock()
	return calls
}

// GetMessage calls GetMessageFunc.
func (mock *A2MInterfaceMock) GetMessage(attestation []byte) ([]byte, error) {
	if mock.GetMessageFunc == nil {
		panic("moq: A2MInterfaceMock.GetMessageFunc is nil but A2MInterface.GetMessage was just called")
	}
	callInfo := struct {
		Attestation []byte
	}{
		Attestation: attestation,
	}
	lockA2MInterfaceMockGetMessage.Lock()
	mock.calls.GetMessage = append(mock.calls.GetMessage, callInfo)
	lockA2MInterfaceMockGetMessage.Unlock()
	return mock.GetMessageFunc(attestation)
}

// GetMessageCalls gets all the calls that were made to GetMessage.
// Check the length with:
//     len(mockedA2MInterface.GetMessageCalls())
func (mock *A2MInterfaceMock) GetMessageCalls() []struct {
	Attestation []byte
} {
	var calls []struct {
		Attestation []byte
	}
	lockA2MInterfaceMockGetMessage.RLock()
	calls = mock.calls.GetMessage
	lockA2MInterfaceMockGetMessage.RUnlock()
	return calls
}

// Lookup calls LookupFunc.
func (mock *A2MInterfaceMock) Lookup(logname string, n int) ([]byte, error) {
	if mock.LookupFunc == nil {
		panic("moq: A2MInterfaceMock.LookupFunc is nil but A2MInterface.Lookup was just called")
	}
	callInfo := struct {
		Logname string
		N       int
	}{
		Logname: logname,
		N:       n,
	}
	lockA2MInterfaceMockLookup.Lock()
	mock.calls.Lookup = append(mock.calls.Lookup, callInfo)
	lockA2MInterfaceMockLookup.Unlock()
	return mock.LookupFunc(logname, n)
}

// LookupCalls gets all the calls that were made to Lookup.
// Check the length with:
//     len(mockedA2MInterface.LookupCalls())
func (mock *A2MInterfaceMock) LookupCalls() []struct {
	Logname string
	N       int
} {
	var calls []struct {
		Logname string
		N       int
	}
	lockA2MInterfaceMockLookup.RLock()
	calls = mock.calls.Lookup
	lockA2MInterfaceMockLookup.RUnlock()
	return calls
}

// StartA2M calls StartA2MFunc.
func (mock *A2MInterfaceMock) StartA2M() {
	if mock.StartA2MFunc == nil {
		panic("moq: A2MInterfaceMock.StartA2MFunc is nil but A2MInterface.StartA2M was just called")
	}
	callInfo := struct {
	}{}
	lockA2MInterfaceMockStartA2M.Lock()
	mock.calls.StartA2M = append(mock.calls.StartA2M, callInfo)
	lockA2MInterfaceMockStartA2M.Unlock()
	mock.StartA2MFunc()
}

// StartA2MCalls gets all the calls that were made to StartA2M.
// Check the length with:
//     len(mockedA2MInterface.StartA2MCalls())
func (mock *A2MInterfaceMock) StartA2MCalls() []struct {
} {
	var calls []struct {
	}
	lockA2MInterfaceMockStartA2M.RLock()
	calls = mock.calls.StartA2M
	lockA2MInterfaceMockStartA2M.RUnlock()
	return calls
}

// Truncate calls TruncateFunc.
func (mock *A2MInterfaceMock) Truncate(logname string, n int) error {
	if mock.TruncateFunc == nil {
		panic("moq: A2MInterfaceMock.TruncateFunc is nil but A2MInterface.Truncate was just called")
	}
	callInfo := struct {
		Logname string
		N       int
	}{
		Logname: logname,
		N:       n,
	}
	lockA2MInterfaceMockTruncate.Lock()
	mock.calls.Truncate = append(mock.calls.Truncate, callInfo)
	lockA2MInterfaceMockTruncate.Unlock()
	return mock.TruncateFunc(logname, n)
}

// TruncateCalls gets all the calls that were made to Truncate.
// Check the length with:
//     len(mockedA2MInterface.TruncateCalls())
func (mock *A2MInterfaceMock) TruncateCalls() []struct {
	Logname string
	N       int
} {
	var calls []struct {
		Logname string
		N       int
	}
	lockA2MInterfaceMockTruncate.RLock()
	calls = mock.calls.Truncate
	lockA2MInterfaceMockTruncate.RUnlock()
	return calls
}

// VerifyAttestation calls VerifyAttestationFunc.
func (mock *A2MInterfaceMock) VerifyAttestation(attestation []byte) (int, error) {
	if mock.VerifyAttestationFunc == nil {
		panic("moq: A2MInterfaceMock.VerifyAttestationFunc is nil but A2MInterface.VerifyAttestation was just called")
	}
	callInfo := struct {
		Attestation []byte
	}{
		Attestation: attestation,
	}
	lockA2MInterfaceMockVerifyAttestation.Lock()
	mock.calls.VerifyAttestation = append(mock.calls.VerifyAttestation, callInfo)
	lockA2MInterfaceMockVerifyAttestation.Unlock()
	return mock.VerifyAttestationFunc(attestation)
}

// VerifyAttestationCalls gets all the calls that were made to VerifyAttestation.
// Check the length with:
//     len(mockedA2MInterface.VerifyAttestationCalls())
func (mock *A2MInterfaceMock) VerifyAttestationCalls() []struct {
	Attestation []byte
} {
	var calls []struct {
		Attestation []byte
	}
	lockA2MInterfaceMockVerifyAttestation.RLock()
	calls = mock.calls.VerifyAttestation
	lockA2MInterfaceMockVerifyAttestation.RUnlock()
	return calls
}

// VerifyMessage calls VerifyMessageFunc.
func (mock *A2MInterfaceMock) VerifyMessage(message []byte, attestation []byte) (int, error) {
	if mock.VerifyMessageFunc == nil {
		panic("moq: A2MInterfaceMock.VerifyMessageFunc is nil but A2MInterface.VerifyMessage was just called")
	}
	callInfo := struct {
		Message     []byte
		Attestation []byte
	}{
		Message:     message,
		Attestation: attestation,
	}
	lockA2MInterfaceMockVerifyMessage.Lock()
	mock.calls.VerifyMessage = append(mock.calls.VerifyMessage, callInfo)
	lockA2MInterfaceMockVerifyMessage.Unlock()
	return mock.VerifyMessageFunc(message, attestation)
}

// VerifyMessageCalls gets all the calls that were made to VerifyMessage.
// Check the length with:
//     len(mockedA2MInterface.VerifyMessageCalls())
func (mock *A2MInterfaceMock) VerifyMessageCalls() []struct {
	Message     []byte
	Attestation []byte
} {
	var calls []struct {
		Message     []byte
		Attestation []byte
	}
	lockA2MInterfaceMockVerifyMessage.RLock()
	calls = mock.calls.VerifyMessage
	lockA2MInterfaceMockVerifyMessage.RUnlock()
	return calls
}

// VerifySkippedAttestation calls VerifySkippedAttestationFunc.
func (mock *A2MInterfaceMock) VerifySkippedAttestation(attestation []byte) (int, error) {
	if mock.VerifySkippedAttestationFunc == nil {
		panic("moq: A2MInterfaceMock.VerifySkippedAttestationFunc is nil but A2MInterface.VerifySkippedAttestation was just called")
	}
	callInfo := struct {
		Attestation []byte
	}{
		Attestation: attestation,
	}
	lockA2MInterfaceMockVerifySkippedAttestation.Lock()
	mock.calls.VerifySkippedAttestation = append(mock.calls.VerifySkippedAttestation, callInfo)
	lockA2MInterfaceMockVerifySkippedAttestation.Unlock()
	return mock.VerifySkippedAttestationFunc(attestation)
}

// VerifySkippedAttestationCalls gets all the calls that were made to VerifySkippedAttestation.
// Check the length with:
//     len(mockedA2MInterface.VerifySkippedAttestationCalls())
func (mock *A2MInterfaceMock) VerifySkippedAttestationCalls() []struct {
	Attestation []byte
} {
	var calls []struct {
		Attestation []byte
	}
	lockA2MInterfaceMockVerifySkippedAttestation.RLock()
	calls = mock.calls.VerifySkippedAttestation
	lockA2MInterfaceMockVerifySkippedAttestation.RUnlock()
	return calls
}
